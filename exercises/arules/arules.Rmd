# Глава 8. Распознование шаблонов: ассоциативные правила.

# Шаг 1. Сбор данных


Данные --- продажи за месяц в одном не очень большом но и не маленьком продуктовом магазине

Что хотим --- найти зависимости среди реализуемых товарах.

```{r}
library(arules)

groceries <- read.transactions("source/Chapter08/groceries.csv", sep = ",")

summary(groceries)
```

# Шаг 2. Исследование и подготовка данных

Данные о транзакциях лучше считывать не как обычный .csv. 
По R-сути --- это готовые вектора, загружать их нужно в разряженную матрицу (та, в которой больше нулей)

Значение density --- это доля ненулевых ячеек матрицы, т.е не трудно посчитать, сколько товаров было продано в этом магазинчике:

```{r}
nrow(groceries) * ncol(groceries) * 0.02609146
```

Элементы в первых транзакциях
```{r}
inspect(groceries[1:5])
```

Частота покупок первых элементов
```{r}
itemFrequency(groceries[, 1:3])
```

## Визуализация

Элементы у которых параметр support больше чем 0.1

```{r}
itemFrequencyPlot(groceries, support = 0.1)
```

Топ самых продаваемых продуктов
```{r}
itemFrequencyPlot(groceries, topN = 20)
```

Можно посмотреть всю разряженную таблицу. Целиком это делать не целесообразно, а вот кусочками можно

```{r}
image(groceries[1:5])
```

Тут можно заметить, что ось X графика имеет больше 150 (а если быть точным то 169) делений. Это как раз по числу столбцом.
Т.е. это как бы продольный кусочек пирога.

По нему можно изучать разного рода закономерности или ошибки в данных.

В целом, таким подходом не очень много находится, но он может быть полезен.

# Шаг 3. Обучение модели

Подбор параметров для функции `apriori()`, может стать целым искусством. 
Например параметры по-умолчанию не подходят, потому что  у нас получается 0 ассоциативных правил.

```{r}
apriori(groceries)
```

## Как установить support

Одним из способов решить проблему выбора минимального значения поддержки состоит в том, чтобы подумать, при каком наименьшем количестве транзакция паттерн будет представлять интерес. Например, моджно решить что если некий товар покупается дважды в день (~60 раз в месяц), то это может быть сигналом важности.
ТАким образом, мы можем вычислить значение support, необходимое для поиска соответствующих как минимум такому кол-ву транзакций.

Поскольку 60 из 9385 это 0,006, то мы сначала попробуем установить уровень support именно таким.


## Как установить confidence

Можно начать с консервативного уровня, и двигаться итеративно. Общего правила тут нет, начнём к примеру с уровня в 25%

```{r}
groceryrules <- apriori(groceries, parameter = list(support =
                          0.006, confidence = 0.25, 
                          # исключаем правила, в котором меньше двух элементов
                          minlen = 2))
groceryrules
```

Итак мы получили 463 правила, для того чтобы понять какие из низ полезные, нужно копнуть глубже

# Шаг 4. Оценка эффективности модели

```{r}
summary(groceryrules)
```

Тут стоит обратить внимание на показатель lift, если он больше единицы, то это верный признак важного правила.

Рассмотрим пример.

```{r}
inspect(groceryrules[1:3])
```

этот вывод для первой строки, дословно означает следующее:

Если покупатель приобретает горшочные растения, то он также покупает и цельное молоко. Из значений support ~0.007 и confidence 0.4 следует, что это правило охватывает около 0,7% транзакций и является верным для 40% покупок, в которые входят растения. 

Значение lift, говорит о том, насколько более вероятно, что покупатель купит цельное молоко, если он приобрел горшочное растение, по сравнению с обычным покупателем. Поскольку мы знаем, что примерно 25,6% покупателей купили цельное молоко и 40% покупателей приобретающих растения купили цельное молоко, то lift = 0,4 / 0,256 = 1,56. Что соответствует значению в выводе функции summary()


При всё при этом, правило {горшочное растение} ->  {молоко}, кажется бесполезным. Потому что нет логической связи между этими двумя товарами.
Тем не менее наши данные говорят об обратном.

Разделим ассоциативные правила на следующие категории

  * полезные
  * тривиальные
  * необъяснимые
  
# Шаг 5. Повышение эффективности модели

В основном всё сводится к тому, чтобы как-то засабсетить уже созданные правила.

```{r}
inspect(sort(groceryrules, by = "lift")[1:5])

berryrules <- subset(groceryrules, items %in% "berries")
inspect(berryrules)
```



